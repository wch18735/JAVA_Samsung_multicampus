

<추상클래스> abstract class
- 후손class를 제어할 목적으로 사용.
- 객체화 될 수 없는 클래스.
- 구현(정의)된 메소드와 선언된 메소드로 구성.
- 스스로 객체생성 불가(new사용X), 후손 class 객체생성(자식은 부모다!!)해서 사용.

형식)
   
   abstract class 클래스명{
      //필드선언
   
      public void hello(){} //구현된(정의된) 메소드
      abstract void print(); //선언된 메소드
      //인터페이스의 경우는 선언된 메소드만 멤버가 될 수 있기 때문에 abstract생략가능!!
      //추상클래스의 경우는 정의된 메소드와의 구별을 위해 반드시 abstract 사용!!
   }
   
   


-----------------------<클래스>--------------------------

class 클래스명{    //----> 정의,구현된 메소드만!!
  void hello(){
  }
}
-----------------------<추상클래스>-----------------------

abstract class 클래스명{ // ----> 정의된 메소드, 선언된메소드 함께 사용 가능
  void hello(){}
  abstract void goodBye();
}

-----------------------<인터페이스>-----------------------
interface 인터페이스명{  // ---> 선언된 메소드만!!
  void hello();
}

-------------------------------------------------------------------
  java.io
BufferedReader클래스의  readLine()메소드를 사용!!

//BufferedReader(Reader in)  <=== API 문서참조 

InputStream is = System.in;

Reader r = new InputStreamReader(is);
// Reader는 추상클래스이므로 자식클래스 중 InputStreamReader클래스를 통해 객체 생성
// (자식은 부모다 ----> 부모클래스가 위치할 곳에 자식클래스가 대신 할 수 있다!!)
BufferedReader br = new BufferedReader(r);
br.readLine();
-------------------------------------------------------------------
java.util.Calendar  ===> 자바에서 날짜관련된 정보를 얻기 위한 클래스
                    ===> 추상클래스
                    
Calendar cal = new Calendar();  //추상클래스는 객체생성 X                     
Calendar cal = new GregorianCalendar();  //자식클래스로 객체 생성 O
Calendar cal = Calendar.getInstance(); 
//추상클래스내에 static한 메소드를 통해 객체생성

==================================================================
<배열> Array
- 데이터형이 동일한 자료에  같은(하나의) 변수명을 정의한 자료들의 집합.
- 데이터형이 동일한 자료 ===> 조건
    같은(하나의) 변수명을 정의 ===> 특성
    자료들의 집합. ===> 정의
    
- 데이터를 구분하기 위해서 번지를 사용.

  int su1;  ---> 한 개의 정수를 저장.
  int su2[]; ---> 여러개의 정수를 저장.
  
  int su2[]={11, 22, 33, 44, 55}; 
         su2[0]  [1] [2] [3] [4] 번지 

- 시작번지는 0번지
- 첫번째 데이터부터 인덱스(자동번호)가 부여
  인덱스는 0부터 시작해서 1씩증가
- 배열의 크기가 정해지면 인덱스를 벗어나는 참조를 하면 안됨.
   int su3[]={10,20,30};
             ----> 배열의 크기(요소 갯수) : 3 (인덱스0~2)
             
   int i=103;
   System.out.println(i);//103
   System.out.println(su3[1]);//20
   System.out.println(su3[3]);
   //에러발생: ArrayIndexOutOfBoundsException

- 배열의 크기(배열의 요소갯수)를 구하는 속성: 배열명.length
- 배열선언시 []는 변수명 앞에 또는 뒤에 붙여도 상관이 없다.

   int su1; //su1에 한개의 정수를 입력하겠음
   
   int su2[]; //배열선언 : su2에 복수의 정수를 입력하겠음
   int []su3; //배열선언 : su3에 복수의 정수를 입력하겠음
   
   int i;
   int j;
   int k;
   
   int i,j,k;
   
   
   int su1,su2,su3[];  //su1,su2,su3은 배열일까요? X
                       //su1,su2는 속성변수, su3은 배열입니다!!
   
   int []su4,su5,su6;  //su4,su5,su6은 배열일까요? O
   
----------------------------------------------------------
 class A{
    int su1;
    
    void print(){
      int su2;
      
      System.out.println(su1);//에러 날까요?  ----> 0 출력
      //--->su1은 멤버변수고 기본값 0을 갖고 있으므로 에러가 발생하지 않습니다.
      
      System.out.println(su2);//에러 날까요?  ----> 에러발생
      //--->su2는 지역변수고 기본값이 없으므로 초기화 하라는 에러발생!!
      
      su2=20;//초기화
      System.out.println(su2);//에러 날까요?  ----> 20 출력
      
    
      int i,j,k=30;
      System.out.println(k);//에러 날까요?    ----> 30 출력 
      System.out.println(j);//에러 날까요?    ----> 에러발생!!
      //---> 30은 k변수에만 초기화!!
      
      int i=10,j=20,k=30;
      
    }
 
 
 }


----------------------------------------------------------

                      
 형식)
  1. 자료형 배열명[] = {데이터list(콤마로 구분되는 데이터)};
          자료형 배열명[] = {value_list};  
  
    ---> 배열선언과 동시에 데이터를 초기화.(이미 데이터가 확정되었을때 사용)
    
    
    ---> ※주의: 배열선언과 데이터초기화하는 부분을 따로 작성할 수 없음!!
    int su[];//배열선언
        su={1,2,3,4,5};//배열초기화  (X)
       
  
  2. 자료형 배열명[] = new 자료형[배열크기]; //배열객체 생성.
    ---> 프로그램 실행 도중 데이터 값을 변경할 때 주로 사용.
    ---> 배열선언과 데이터초기화하는 부분을 따로 작성하는 것이 가능.
    ---> 배열크기[]는 반드시 자료형 뒤에 위치해야 함.
               배열크기에는 정수값이 반드시 입력되어야 함. 
               
    int su[]= new int[5];//앞으로 int데이터를 5개 받겠습니다.(5개의 빈방만들기!!)           
  
        su[0]=11;
        su[1]=22;
        su[2]=33;
        su[3]=44;
        
         ※배열객체생성을 하게 되면 그 위치에 상관없이 각 방에는 초기값이 부여됨(멤버변수처럼)!!   
  
 class A{
    int su[]=new int[3];
    
    
    void print(){
       System.out.println(su[0]);//0
       System.out.println(su[1]);//0
       System.out.println(su[2]);//0
       su[1]=22;
       System.out.println(su[1]);//22
       
       int su2[]=new int[3];
           System.out.println(su2[0]);//0
           System.out.println(su2[1]);//0
           System.out.println(su2[2]);//0
    
    }
 
 
 
 } 
  
  
  

<2차원 배열>
   - 실제 저장은 1차원 배열과 같으나
          논리적으로 데이터를 행과 열의 형태로 저장한다고 생각.
   - 행사이즈는 반드시 기술해야함.
         열사이즈는 생략하는 것이 가능.
         
      int su[][];
      int [][]su;
      int []su[];
      
      int su[][] = new int[행크기][열크기];  
      int su[][] = new int[3][2]; 
                     //3*2=6 : 6개의 데이터를 3행 2열의 형태로 저장.
           
            0     1  열  
          -----------     
        0 |  0 | 30 
        1 | 10 |  0
        2 |  0 | 20        
              행       
            
       값 저장
      ==> su[1][0] = 10;
          su[2][1] = 20;
          su[0][1] = 30;      
           
           
<가변길이 열사용> - 각 행마다 서로 다른 열을 갖는 것이 가능
   int su[][] = new int[3][]; //열 사이즈를 생략
   
    su[0] = new int[2]; //첫번째 행의 열사이즈를 지정
    su[1] = new int[3]; //두번째 행의 열사이즈를 지정
    su[2] = new int[4]; //세번째 행의 열사이즈를 지정

       행
    0 방 2개생성
    1 방 3개생성
    2 방 4개생성
               
                        행          0      1       2               
   int su[][] = { {1,2}, {3,4}, {5,6} };
                        열        0 1    0 1    0 1
                        
    su.length --->? 3 (행의 갯수와 일치)
       데이터 3을 출력하고 싶다?   System.out.println(su[1][0]);
       
       
    int su2[][] = { {1},         {2,     3},    {4,      5,   6} };    
                   su2[0][0]    [1][0] [1][1]  [2][0] [2][1] [2][2]
       
        su2[0].length ---> 0행의 열(데이터)갯수 ---> 1
        su2[1].length ---> 1행의 열(데이터)갯수 ---> 2
        su2[2].length ---> 2행의 열(데이터)갯수 ---> 3
       
      전체데이터를 출력)
      
      for(int i=0; i<su.length; i++){//행 인덱스를 표현 (0~2)
        for(int j=0; j<su[i].length; j++){//열 인덱스를 표현 (0~1)
           System.out.println(su[i][j]);
        }
      }                         
































   